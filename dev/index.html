<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Polynomials.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="Polynomials.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Polynomials.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start-1"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Relationship-between-the-T-and-P{T,X}-1"><span>Relationship between the <code>T</code> and <code>P{T,X}</code></span></a></li><li><a class="tocitem" href="#Related-Packages-1"><span>Related Packages</span></a></li><li><a class="tocitem" href="#Contributing-1"><span>Contributing</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference/API</a></li><li><span class="tocitem">Polynomial Types</span><ul><li><a class="tocitem" href="polynomials/polynomial/">Polynomial</a></li><li><a class="tocitem" href="polynomials/chebyshev/">Chebyshev</a></li></ul></li><li><a class="tocitem" href="extending/">Extending</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Polynomials.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polynomials.jl-1"><a class="docs-heading-anchor" href="#Polynomials.jl-1">Polynomials.jl</a><a class="docs-heading-anchor-permalink" href="#Polynomials.jl-1" title="Permalink"></a></h1><p>Polynomials.jl is a Julia package that provides basic arithmetic, integration, differentiation, evaluation, and root finding over dense univariate polynomials.</p><p>To install the package, run</p><pre><code class="language-julia">(v1.2) pkg&gt; add Polynomials</code></pre><p>The package can then be loaded into the current session using</p><pre><code class="language-julia">using Polynomials</code></pre><h2 id="Quick-Start-1"><a class="docs-heading-anchor" href="#Quick-Start-1">Quick Start</a><a class="docs-heading-anchor-permalink" href="#Quick-Start-1" title="Permalink"></a></h2><h3 id="Construction-and-Evaluation-1"><a class="docs-heading-anchor" href="#Construction-and-Evaluation-1">Construction and Evaluation</a><a class="docs-heading-anchor-permalink" href="#Construction-and-Evaluation-1" title="Permalink"></a></h3><p>Construct a polynomial from its coefficients, lowest order first.</p><pre><code class="language-julia-repl">julia&gt; Polynomial([1,0,3,4])
Polynomial(1 + 3*x^2 + 4*x^3)</code></pre><p>An optional variable parameter can be added.</p><pre><code class="language-julia-repl">julia&gt; Polynomial([1,2,3], :s)
Polynomial(1 + 2*s + 3*s^2)</code></pre><p>Construct a polynomial from its roots.</p><pre><code class="language-julia-repl">julia&gt; fromroots([1,2,3]) # (x-1)*(x-2)*(x-3)
Polynomial(-6 + 11*x - 6*x^2 + x^3)</code></pre><p>Evaluate the polynomial <code>p</code> at <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1, 0, -1])
Polynomial(1 - x^2)

julia&gt; p(1)
0
</code></pre><h3 id="Arithmetic-1"><a class="docs-heading-anchor" href="#Arithmetic-1">Arithmetic</a><a class="docs-heading-anchor-permalink" href="#Arithmetic-1" title="Permalink"></a></h3><p>The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1,2])
Polynomial(1 + 2*x)

julia&gt; q = Polynomial([1, 0, -1])
Polynomial(1 - x^2)

julia&gt; 2p
Polynomial(2 + 4*x)

julia&gt; 2 + p
Polynomial(3 + 2*x)

julia&gt; p - q
Polynomial(2*x + x^2)

julia&gt; p * q
Polynomial(1 + 2*x - x^2 - 2*x^3)

julia&gt; q / 2
Polynomial(0.5 - 0.5*x^2)

julia&gt; q ÷ p  # `div`, also `rem` and `divrem`
Polynomial(0.25 - 0.5*x)</code></pre><p>Note that operations involving polynomials with different variables will error.</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1, 2, 3], :x)
Polynomial(1 + 2*x + 3*x^2)

julia&gt; q = Polynomial([1, 2, 3], :s)
Polynomial(1 + 2*s + 3*s^2)

julia&gt; p + q
ERROR: ArgumentError: Polynomials have different indeterminates
[...]</code></pre><p>Except for operations  involving constant polynomials.</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1, 2, 3], :x)
Polynomial(1 + 2*x + 3*x^2)

julia&gt; q = Polynomial(1, :y)
Polynomial(1)

julia&gt; p+q
Polynomial(2 + 2*x + 3*x^2)</code></pre><h3 id="Integrals-and-Derivatives-1"><a class="docs-heading-anchor" href="#Integrals-and-Derivatives-1">Integrals and Derivatives</a><a class="docs-heading-anchor-permalink" href="#Integrals-and-Derivatives-1" title="Permalink"></a></h3><p>Integrate the polynomial <code>p</code> term by term, optionally adding constant term <code>C</code>. The degree of the resulting polynomial is one higher than the degree of <code>p</code>.</p><pre><code class="language-julia-repl">julia&gt; integrate(Polynomial([1, 0, -1]))
Polynomial(1.0*x - 0.3333333333333333*x^3)

julia&gt; integrate(Polynomial([1, 0, -1]), 2)
Polynomial(2.0 + 1.0*x - 0.3333333333333333*x^3)</code></pre><p>Differentiate the polynomial <code>p</code> term by term. The degree of the resulting polynomial is one lower than the degree of <code>p</code>.</p><pre><code class="language-julia-repl">julia&gt; derivative(Polynomial([1, 3, -1]))
Polynomial(3 - 2*x)</code></pre><h3 id="Root-finding-1"><a class="docs-heading-anchor" href="#Root-finding-1">Root-finding</a><a class="docs-heading-anchor-permalink" href="#Root-finding-1" title="Permalink"></a></h3><p>Return the roots (zeros) of <code>p</code>, with multiplicity. The number of roots returned is equal to the order of <code>p</code>. By design, this is not type-stable, the returned roots may be real or complex.</p><pre><code class="language-julia-repl">julia&gt; roots(Polynomial([1, 0, -1]))
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; roots(Polynomial([1, 0, 1]))
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; roots(Polynomial([0, 0, 1]))
2-element Vector{Float64}:
 0.0
 0.0</code></pre><h3 id="Fitting-arbitrary-data-1"><a class="docs-heading-anchor" href="#Fitting-arbitrary-data-1">Fitting arbitrary data</a><a class="docs-heading-anchor-permalink" href="#Fitting-arbitrary-data-1" title="Permalink"></a></h3><p>Fit a polynomial (of degree <code>deg</code>) to <code>x</code> and <code>y</code> using polynomial interpolation or a (weighted) least-squares approximation.</p><pre><code class="language-julia">using Plots, Polynomials
xs = range(0, 10, length=10)
ys = @. exp(-xs)
f = fit(xs, ys) # degree = length(xs) - 1
f2 = fit(xs, ys, 2) # degree = 2

scatter(xs, ys, markerstrokewidth=0, label=&quot;Data&quot;)
plot!(f, extrema(xs)..., label=&quot;Fit&quot;)
plot!(f2, extrema(xs)..., label=&quot;Quadratic Fit&quot;)</code></pre><pre><code class="language-none">qt.qpa.xcb: could not connect to display
qt.qpa.plugin: Could not load the Qt platform plugin &quot;xcb&quot; in &quot;&quot; even though it was found.
This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.

Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb.

Aborted (core dumped)
connect: Connection refused
GKS: can&#39;t connect to GKS socket application

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="polyfit.svg" alt/></p><h3 id="Other-bases-1"><a class="docs-heading-anchor" href="#Other-bases-1">Other bases</a><a class="docs-heading-anchor-permalink" href="#Other-bases-1" title="Permalink"></a></h3><p>A polynomial, e.g. <code>a_0 + a_1 x + a_2 x^2 + ... + a_n x^n</code>, can be seen as a collection of coefficients, <code>[a_0, a_1, ..., a_n]</code>, relative to some polynomial basis. The most  familiar basis being  the standard one: <code>1</code>, <code>x</code>, <code>x^2</code>, ...  Alternative bases are possible.  The <code>ChebyshevT</code> polynomials are  implemented, as an example. Instead of <code>Polynomial</code>  or  <code>Polynomial{T}</code>, <code>ChebyshevT</code> or  <code>ChebyshevT{T}</code> constructors are used:</p><pre><code class="language-julia-repl">julia&gt; p1 = ChebyshevT([1.0, 2.0, 3.0])
ChebyshevT(1.0⋅T_0(x) + 2.0⋅T_1(x) + 3.0⋅T_2(x))

julia&gt; p2 = ChebyshevT{Float64}([0, 1, 2])
ChebyshevT(1.0⋅T_1(x) + 2.0⋅T_2(x))

julia&gt; p1 + p2
ChebyshevT(1.0⋅T_0(x) + 3.0⋅T_1(x) + 5.0⋅T_2(x))

julia&gt; p1 * p2
ChebyshevT(4.0⋅T_0(x) + 4.5⋅T_1(x) + 3.0⋅T_2(x) + 3.5⋅T_3(x) + 3.0⋅T_4(x))

julia&gt; derivative(p1)
ChebyshevT(2.0⋅T_0(x) + 12.0⋅T_1(x))

julia&gt; integrate(p2)
ChebyshevT(- 1.0⋅T_1(x) + 0.25⋅T_2(x) + 0.3333333333333333⋅T_3(x))

julia&gt; convert(Polynomial, p1)
Polynomial(-2.0 + 2.0*x + 6.0*x^2)

julia&gt; convert(ChebyshevT, Polynomial([1.0, 2,  3]))
ChebyshevT(2.5⋅T_0(x) + 2.0⋅T_1(x) + 1.5⋅T_2(x))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The older  <code>Poly</code> type that this package used prior to <code>v0.7</code>  is implemented as an alternate basis  to provide support for older code bases. As of <code>v1.0</code>,  this type will be only available by executing <code>using Polynomials.PolyCompat</code>.</p></div></div><h3 id="Iteration-1"><a class="docs-heading-anchor" href="#Iteration-1">Iteration</a><a class="docs-heading-anchor-permalink" href="#Iteration-1" title="Permalink"></a></h3><p>If its basis is implicit, then a polynomial may be  seen as just a vector of  coefficients. Vectors or 1-based, but, for convenience, polynomial types are 0-based, for purposes of indexing (e.g. <code>getindex</code>, <code>setindex!</code>, <code>eachindex</code>). Iteration over a polynomial steps through the underlying coefficients.</p><pre><code class="language-julia-repl">julia&gt; as = [1,2,3,4,5]; p = Polynomial(as);

julia&gt; as[3], p[2], collect(p)[3]
(3, 3, 3)</code></pre><p>The <code>pairs</code> iterator, iterates over the indices and coefficients, attempting to match how <code>pairs</code> applies to the underlying storage model:</p><pre><code class="language-julia-repl">julia&gt; v = [1,2,0,4]
4-element Vector{Int64}:
 1
 2
 0
 4

julia&gt; p,ip,sp,lp = Polynomial(v), ImmutablePolynomial(v), SparsePolynomial(v), LaurentPolynomial(v, -1);

julia&gt; collect(pairs(p))
4-element Vector{Pair{Int64, Int64}}:
 0 =&gt; 1
 1 =&gt; 2
 2 =&gt; 0
 3 =&gt; 4

julia&gt; collect(pairs(ip)) == collect(pairs(p))
true

julia&gt; collect(pairs(sp)) # unordered dictionary with only non-zero terms
3-element Vector{Pair{Int64, Int64}}:
 0 =&gt; 1
 3 =&gt; 4
 1 =&gt; 2

julia&gt; collect(pairs(lp))
4-element Vector{Pair{Int64, Int64}}:
 -1 =&gt; 1
  0 =&gt; 2
  1 =&gt; 0
  2 =&gt; 4</code></pre><p>The unexported <code>monomials</code> iterator iterates over the terms (<code>p[i]*Polynomials.basis(p,i)</code>) of the polynomial:</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1,2,0,4], :u)
Polynomial(1 + 2*u + 4*u^3)

julia&gt; collect(Polynomials.monomials(p))
4-element Vector{Any}:
 Polynomial(1)
 Polynomial(2*u)
 Polynomial(0)
 Polynomial(4*u^3)</code></pre><h2 id="Relationship-between-the-T-and-P{T,X}-1"><a class="docs-heading-anchor" href="#Relationship-between-the-T-and-P{T,X}-1">Relationship between the <code>T</code> and <code>P{T,X}</code></a><a class="docs-heading-anchor-permalink" href="#Relationship-between-the-T-and-P{T,X}-1" title="Permalink"></a></h2><p>The addition of a polynomial and a scalar, such as</p><pre><code class="language-julia-repl">julia&gt; using Polynomials

julia&gt; p = Polynomial([1,2,3], :x)
Polynomial(1 + 2*x + 3*x^2)

julia&gt; p + 3
Polynomial(4 + 2*x + 3*x^2)</code></pre><p>seems natural, but in <code>Julia</code>, as <code>3</code> is of type <code>Int</code> and <code>p</code> of type <code>Polynomial{Int,:x}</code> some addition must be defined. The basic idea  is that <code>3</code> is promoted to the <em>constant</em> polynomial <code>3</code> with indeterminate <code>:x</code> as <code>3*one(p)</code> and then addition of <code>p + 3*one(p)</code> is performed.</p><p>This identification of a scalar with a constant polynomial can go both ways. If <code>q</code> is a <em>constant</em> polynomial of type <code>Polynomial{Int, :y}</code> then we should expect that <code>p+q</code> would be defined, as <code>p</code> plus the constant term of <code>q</code>. Indeed this is the case</p><pre><code class="language-julia-repl">julia&gt; q = Polynomial(3, :y)
Polynomial(3)

julia&gt; p + q
Polynomial(4 + 2*x + 3*x^2)</code></pre><p>If <code>q</code> is non-constant, such as <code>variable(Polynomial, :y)</code>, then there would be an error due to the mismatched symbols. (The mathematical result would need a multivariate polynomial, not a univariate polynomial, as this package provides.)</p><p>The same conversion is done for polynomial multiplication: constant polynomials are treated as numbers; non-constant polynomials must have their symbols match. </p><p>There is an oddity though the following two computations look the same, they are technically different:</p><pre><code class="language-julia-repl">julia&gt; one(Polynomial, :x) + one(Polynomial, :y)
Polynomial(2.0)

julia&gt; one(Polynomial, :y) + one(Polynomial, :x)
Polynomial(2.0)</code></pre><p>Both are constant polynomials over <code>Int</code>, but the first has the indeterminate <code>:y</code>, the second <code>:x</code>. </p><p>This technical difference causes no issues with polynomial addition or multiplication, as there constant polynomials are treated as numbers, but can be an issue when constant polynomials are used as array elements.</p><p>For arrays, the promotion of numbers to polynomials, allows natural constructions like:</p><pre><code class="language-julia-repl">julia&gt; p = Polynomial([1,2],:x)
Polynomial(1 + 2*x)

julia&gt; q = Polynomial([1,2],:y)  # non-constant polynomials with different indeterminates
Polynomial(1 + 2*y)

julia&gt; [1 p]
1×2 Matrix{Polynomial{Int64, :x}}:
 Polynomial(1)  Polynomial(1 + 2*x)

julia&gt; [1 one(q)]
1×2 Matrix{Polynomial{Int64, :y}}:
 Polynomial(1)  Polynomial(1)</code></pre><p>However, as there would be an ambiguous outcome of the following</p><pre><code class="language-julia-repl">julia&gt; [one(p) one(q)]
ERROR: ArgumentError: Polynomials have different indeterminates
[...]</code></pre><p>an error thrown.</p><p>In general, arrays with mixtures of non-constant polynomials with <em>different</em> indeterminates will error. By default, an error will occur when constant polynomials with different indeterminates are used as components. However, for <em>typed</em> arrays, conversion will allow such constructs to be used.</p><p>Using <code>one(q)</code> for a constant polynomial with indeterminate <code>:y</code> we have:</p><pre><code class="language-julia-repl">julia&gt; P = typeof(p)
Polynomial{Int64, :x}

julia&gt; P[one(p) one(q)]
1×2 Matrix{Polynomial{Int64, :x}}:
 Polynomial(1)  Polynomial(1)</code></pre><p>Of course, by not being explicit, there are sill gotchas. For example, we can construct this matrix without a specific types:</p><pre><code class="language-julia-repl">julia&gt; [one(p), one(q)+one(p)]
2-element Vector{Polynomial{Int64, :x}}:
 Polynomial(1)
 Polynomial(2)</code></pre><p>but not this one:</p><pre><code class="language-julia-repl">julia&gt; [one(p), one(p) + one(q)]
ERROR: ArgumentError: Polynomials have different indeterminates
[...]</code></pre><p>Also, mixing types can result in unspecific symbols, as this example shows:</p><pre><code class="language-julia-repl">julia&gt; [1 p; p 1] + [1 2one(q); 3 4] # array{P{T,:x}} + array{P{T,:y}}
2×2 Matrix{Polynomial{Int64, X} where X}:
 Polynomial(2)        Polynomial(3 + 2*x)
 Polynomial(4 + 2*x)  Polynomial(5)</code></pre><p>Though were a non-constant polynomial with indeterminate <code>y</code> replacing <code>2one(q)</code> above, that addition would throw an error.</p><h2 id="Related-Packages-1"><a class="docs-heading-anchor" href="#Related-Packages-1">Related Packages</a><a class="docs-heading-anchor-permalink" href="#Related-Packages-1" title="Permalink"></a></h2><ul><li><p><a href="https://github.com/tkoolen/StaticUnivariatePolynomials.jl">StaticUnivariatePolynomials.jl</a> Fixed-size univariate polynomials backed by a Tuple</p></li><li><p><a href="https://github.com/daviddelaat/MultiPoly.jl">MultiPoly.jl</a> for sparse multivariate polynomials</p></li><li><p><a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomals.jl</a> Multivariate polynomials implementation of commutative and non-commutative variables</p></li><li><p><a href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl">MultivariatePolynomials.jl</a> for multivariate polynomials and moments of commutative or non-commutative variables</p></li><li><p><a href="https://github.com/tkluck/PolynomialRings.jl">PolynomialRings.jl</a> A library for arithmetic and algebra with multi-variable polynomials.</p></li><li><p><a href="https://github.com/wbhart/AbstractAlgebra.jl">AbstractAlgebra.jl</a>, <a href="https://github.com/wbhart/Nemo.jl">Nemo.jl</a> for generic polynomial rings, matrix spaces, fraction fields, residue rings, power series, <a href="https://github.com/thofma/Hecke.jl">Hecke.jl</a> for algebraic number theory.</p></li><li><p><a href="https://github.com/KlausC/CommutativeRings.jl">CommutativeAlgebra.jl</a> the start of a computer algebra system specialized to discrete calculations with support for polynomials.</p></li><li><p><a href="https://github.com/giordano/PolynomialRoots.jl">PolynomialRoots.jl</a> for a fast complex polynomial root finder. For larger degree problems, also <a href="https://github.com/andreasnoack/FastPolynomialRoots.jl">FastPolynomialRoots</a> and <a href="https://github.com/jverzani/AMRVW.jl">AMRVW</a>.</p></li><li><p><a href="https://github.com/jverzani/SpecialPolynomials.jl">SpecialPolynomials.jl</a> A package providing various polynomial types beyond the standard basis polynomials in <code>Polynomials.jl</code>. Includes interpolating polynomials, Bernstein polynomials, and classical orthogonal polynomials.</p></li><li><p><a href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl">ClassicalOrthogonalPolynomials.jl</a> A Julia package for classical orthogonal polynomials and expansions. Includes <code>chebyshevt</code>, <code>chebyshevu</code>, <code>legendrep</code>, <code>jacobip</code>, <code>ultrasphericalc</code>, <code>hermiteh</code>, and <code>laguerrel</code>. The same repository includes <code>FastGaussQuadrature.jl</code>, <code>FastTransforms.jl</code>, and the <code>ApproxFun</code> packages.</p></li></ul><h2 id="Contributing-1"><a class="docs-heading-anchor" href="#Contributing-1">Contributing</a><a class="docs-heading-anchor-permalink" href="#Contributing-1" title="Permalink"></a></h2><p>If you are interested in this project, feel free to open an issue or pull request! In general, any changes must be thoroughly tested, allow deprecation, and not deviate too far from the common interface. All PR&#39;s must have an updated project version, as well, to keep the continuous delivery cycle up-to-date.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference/API »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 20 April 2021 21:51">Tuesday 20 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
