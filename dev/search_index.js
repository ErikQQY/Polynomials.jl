var documenterSearchIndex = {"docs":
[{"location":"extending/#Extending-Polynomials-1","page":"Extending","title":"Extending Polynomials","text":"","category":"section"},{"location":"extending/#","page":"Extending","title":"Extending","text":"The AbstractPolynomial type was made to be extended via a rich interface.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"AbstractPolynomial","category":"page"},{"location":"extending/#Polynomials.AbstractPolynomial","page":"Extending","title":"Polynomials.AbstractPolynomial","text":"AbstractPolynomial{T,X}\n\nAn abstract container for various polynomials. \n\nProperties\n\ncoeffs - The coefficients of the polynomial\n\n\n\n\n\n","category":"type"},{"location":"extending/#","page":"Extending","title":"Extending","text":"A polynomial's  coefficients  are  relative to some basis. The Polynomial type relates coefficients  [a0, a1,  ..., an], say,  to the  polynomial  a0 +  a1*x + a2*x^  + ... +  an*x^n,  through the standard  basis  1,  x,  x^2, ..., x^n.  New polynomial  types typically represent the polynomial through a different  basis. For example,  CheyshevT uses a basis  T_0=1, T_1=x,  T_2=2x^2-1,  ...,  T_n  =  2xT_{n-1} - T_{n-2}.  For this type  the  coefficients  [a0,a1,...,an] are associated with  the polynomial  a0*T0  + a1*T_1 +  ...  +  an*T_n.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"To implement a new polynomial type, P, the following methods should be implemented.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"note: Note\nPromotion rules will always coerce towards the Polynomial type, so not all methods have to be implemented if you provide a conversion function.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"As always, if the default implementation does not work or there are more efficient ways of implementing, feel free to overwrite functions from common.jl for your type.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Function Required Notes\nConstructor x \nType function ((::P)(x)) x \nconvert(::Polynomial, ...)  Not required, but the library is built off the Polynomial type, so all operations are guaranteed to work with it. Also consider writing the inverse conversion method.\nPolynomials.evalpoly(x, p::P) to evaluate the polynomial at x (Base.evalpoly okay post v\"1.4.0\") \ndomain x Should return an  AbstractInterval\nvander  Required for fit\ncompanion  Required for roots\n*(::P, ::P)  Multiplication of polynomials\ndivrem  Required for gcd\none  Convenience to find constant in new basis\nvariable  Convenience to find monomial x in new  basis","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Check out both the Polynomial and ChebyshevT for examples of this interface being extended. ","category":"page"},{"location":"extending/#Example-1","page":"Extending","title":"Example","text":"","category":"section"},{"location":"extending/#","page":"Extending","title":"Extending","text":"The following shows a minimal example where the polynomial aliases the vector defining the coefficients.  The constructor ensures that there are no trailing zeros. The @register call ensures a common interface. This example subtypes StandardBasisPolynomial, not AbstractPolynomial, and consequently inherits the methods above that otherwise would have been required. For other bases, more methods may be necessary to define (again, refer to ChebyshevT for an example).","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> using Polynomials\n\njulia> struct AliasPolynomial{T <: Number, X} <: Polynomials.StandardBasisPolynomial{T, X}\n                  coeffs::Vector{T}\n                  function AliasPolynomial{T, X}(coeffs::Vector{S}) where {T, X, S}\n                      p = new{T,X}(coeffs)\n                      chop!(p)\n                  end\n              end\n\njulia> Polynomials.@register AliasPolynomial","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"To see this new polynomial type in action, we have:","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> xs = [1,2,3,4];\n\njulia> p = AliasPolynomial(xs)\nAliasPolynomial(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> q = AliasPolynomial(1.0, :y)\nAliasPolynomial(1.0)\n\njulia> p + q\nAliasPolynomial(2.0 + 2.0*x + 3.0*x^2 + 4.0*x^3)\n\njulia> p * p\nAliasPolynomial(1 + 4*x + 10*x^2 + 20*x^3 + 25*x^4 + 24*x^5 + 16*x^6)\n\njulia> (derivative ∘ integrate)(p) == p\ntrue\n\njulia> p(3)\n142","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"For the Polynomial type, the default on operations is to copy the array. For this type, it might seem reasonable – to avoid allocations – to update the coefficients in place for scalar addition and scalar multiplication. ","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Scalar addition, p+c, defaults to p + c*one(p), or polynomial addition, which is not inplace without addition work. As such, we create a new method and an infix operator","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> function scalar_add!(p::AliasPolynomial{T}, c::T) where {T}\n           p.coeffs[1] += c\n           p\n       end;\n\njulia> p::AliasPolynomial ⊕ c::Number = scalar_add!(p,c);\n","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Then we have:","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> p\nAliasPolynomial(1 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p ⊕ 2\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"The viewpoint that a polynomial represents a vector of coefficients  leads to an expectation that vector operations should match when possible. Scalar multiplication is a vector operation, so it seems reasonable to override the broadcast machinery to implement an in place operation (e.g. p .*= 2). By default, the polynomial types are not broadcastable over their coefficients. We would need to make a change there and modify the copyto! function:","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> Base.broadcastable(p::AliasPolynomial) = p.coeffs;\n\n\njulia> Base.ndims(::Type{<:AliasPolynomial}) = 1\n\n\njulia> Base.copyto!(p::AliasPolynomial, x) = (copyto!(p.coeffs, x); chop!(p));\n","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"The last chop! call would ensure that there are no trailing zeros in the coefficient vector after multiplication, as multiplication by 0 is possible.","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Then we might have:","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> p\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)\n\njulia> p .*= 2\nAliasPolynomial(6 + 4*x + 6*x^2 + 8*x^3)\n\njulia> p\nAliasPolynomial(6 + 4*x + 6*x^2 + 8*x^3)\n\njulia> p ./= 2\nAliasPolynomial(3 + 2*x + 3*x^2 + 4*x^3)","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Trying to divide again would throw an error, as the result would not fit with the integer type of p. ","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"Now p is treated as the vector p.coeffs, as regards broadcasting, so some things may be surprising, for example this expression returns a vector, not a polynomial:","category":"page"},{"location":"extending/#","page":"Extending","title":"Extending","text":"julia> p .+ 2\n4-element Vector{Int64}:\n 5\n 4\n 5\n 6","category":"page"},{"location":"polynomials/polynomial/#Polynomial-1","page":"Polynomial","title":"Polynomial","text":"","category":"section"},{"location":"polynomials/polynomial/#","page":"Polynomial","title":"Polynomial","text":"Polynomial types using the standard basis.","category":"page"},{"location":"polynomials/polynomial/#","page":"Polynomial","title":"Polynomial","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"polynomials/polynomial/#","page":"Polynomial","title":"Polynomial","text":"Polynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.Polynomial","page":"Polynomial","title":"Polynomials.Polynomial","text":"Polynomial{T<:Number, X}(coeffs::AbstractVector{T}, [var = :x])\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var which may be a character, symbol, or a string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through Polynomial([a_0, a_1, ..., a_n]).\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two polynomials of different variables causes an error except those involving a constant polynomial.\n\nnote: Note\nPolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first  index always corresponding to the constant term. In order to use the axis of coeffs as exponents,  consider using a LaurentPolynomial or possibly a SparsePolynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> Polynomial([1, 0, 3, 4])\nPolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> one(Polynomial)\nPolynomial(1.0)\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#","page":"Polynomial","title":"Polynomial","text":"ImmutablePolynomial\nSparsePolynomial\nLaurentPolynomial","category":"page"},{"location":"polynomials/polynomial/#Polynomials.ImmutablePolynomial","page":"Polynomial","title":"Polynomials.ImmutablePolynomial","text":"ImmutablePolynomial{T<:Number, X, N}(coeffs::AbstractVector{T})\n\nConstruct an immutable (static) polynomial from its coefficients  a₀, a₁, …, aₙ, lowest order first, optionally in terms of the given variable x where x can be a character, symbol, or string.\n\nIf p = a_n x^n + ldots + a_2 x^2 + a_1 x + a_0, we construct this through ImmutablePolynomial((a_0, a_1, ..., a_n)) (assuming a_n ≠ 0). As well, a vector or number can be used for construction.\n\nThe usual arithmetic operators are overloaded to work with polynomials as well as with combinations of polynomials and scalars. However, operations involving two non-constant polynomials of different variables causes an error. Unlike other polynomials, setindex! is not defined for ImmutablePolynomials.\n\nAs the coefficient size is a compile-time constant, several performance improvements are possible. For example, immutable polynomials can take advantage of  faster polynomial evaluation provided by evalpoly from Julia 1.4.\n\nnote: Note\nImmutablePolynomial is not axis-aware, and it treats coeffs simply as a list of coefficients with the first  index always corresponding to the constant term.\n\nExamples\n\njulia> using  Polynomials\n\njulia> ImmutablePolynomial((1, 0, 3, 4))\nImmutablePolynomial(1 + 3*x^2 + 4*x^3)\n\njulia> ImmutablePolynomial((1, 2, 3), :s)\nImmutablePolynomial(1 + 2*s + 3*s^2)\n\njulia> one(ImmutablePolynomial)\nImmutablePolynomial(1.0)\n\nnote: Note\nThis was modeled after https://github.com/tkoolen/StaticUnivariatePolynomials.jl by @tkoolen.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Polynomials.SparsePolynomial","page":"Polynomial","title":"Polynomials.SparsePolynomial","text":"SparsePolynomial{T, X}(coeffs::Dict, [var = :x])\n\nPolynomials in the standard basis backed by a dictionary holding the non-zero coefficients. For polynomials of high degree, this might be advantageous. Addition and multiplication with constant polynomials are treated as having no symbol.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P  = SparsePolynomial\nSparsePolynomial\n\njulia> p, q = P([1,2,3]), P([4,3,2,1])\n(SparsePolynomial(1 + 2*x + 3*x^2), SparsePolynomial(4 + 3*x + 2*x^2 + x^3))\n\njulia> p + q\nSparsePolynomial(5 + 5*x + 5*x^2 + x^3)\n\njulia> p * q\nSparsePolynomial(4 + 11*x + 20*x^2 + 14*x^3 + 8*x^4 + 3*x^5)\n\njulia> p + 1\nSparsePolynomial(2 + 2*x + 3*x^2)\n\njulia> q * 2\nSparsePolynomial(8 + 6*x + 4*x^2 + 2*x^3)\n\njulia> p = Polynomials.basis(P, 10^9) - Polynomials.basis(P,0) # also P(Dict(0=>-1, 10^9=>1))\nSparsePolynomial(-1.0 + 1.0*x^1000000000)\n\njulia> p(1)\n0.0\n\n\n\n\n\n","category":"type"},{"location":"polynomials/polynomial/#Polynomials.LaurentPolynomial","page":"Polynomial","title":"Polynomials.LaurentPolynomial","text":"LaurentPolynomial{T,X}(coeffs::AbstractVector, [m::Integer = 0], [var = :x])\n\nA Laurent polynomial is of the form a_{m}x^m + ... + a_{n}x^n where m,n are  integers (not necessarily positive) with m <= n.\n\nThe coeffs specify a_{m}, a_{m-1}, ..., a_{n}.  The argument m represents the lowest exponent of the variable in the series, and is taken to be zero by default.\n\nLaurent polynomials and standard basis polynomials promote to  Laurent polynomials. Laurent polynomials may be  converted to a standard basis  polynomial when m >= 0 .\n\nIntegration will fail if there is a x⁻¹ term in the polynomial.\n\nnote: Note\nLaurentPolynomial is not axis-aware by default, and it treats coeffs simply as a  list of coefficients with the first index always corresponding to the constant term.  In order to use the axis of coeffs as the exponents of the variable var,  set m to firstindex(coeff) in the constructor.\n\nExamples:\n\njulia> using Polynomials\n\njulia> P = LaurentPolynomial\nLaurentPolynomial\n\njulia> p = P([1,1,1],  -1)\nLaurentPolynomial(x⁻¹ + 1 + x)\n\njulia> q = P([1,1,1])\nLaurentPolynomial(1 + x + x²)\n\njulia> pp = Polynomial([1,1,1])\nPolynomial(1 + x + x^2)\n\njulia> p + q\nLaurentPolynomial(x⁻¹ + 2 + 2*x + x²)\n\njulia> p * q\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> p * pp\nLaurentPolynomial(x⁻¹ + 2 + 3*x + 2*x² + x³)\n\njulia> pp - q\nLaurentPolynomial(0)\n\njulia> derivative(p)\nLaurentPolynomial(-x⁻² + 1)\n\njulia> integrate(q)\nLaurentPolynomial(1.0*x + 0.5*x² + 0.3333333333333333*x³)\n\njulia> integrate(p)  # x⁻¹  term is an issue\nERROR: ArgumentError: Can't integrate Laurent  polynomial with  `x⁻¹` term\n\njulia> integrate(P([1,1,1], -5))\nLaurentPolynomial(-0.25*x⁻⁴ - 0.3333333333333333*x⁻³ - 0.5*x⁻²)\n\njulia> x⁻¹ = inv(variable(LaurentPolynomial)) # `inv` defined on monomials\nLaurentPolynomial(1.0*x⁻¹)\n\njulia> p = Polynomial([1,2,3])\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> x = variable()\nPolynomial(x)\n\njulia> x^degree(p) * p(x⁻¹) # reverses  coefficients\nLaurentPolynomial(3.0 + 2.0*x + 1.0*x²)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Reference/API-1","page":"Reference/API","title":"Reference/API","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"All polynomials have the following functionality. In some cases, there is not a direct function call and therefore the polynomials have to be converted to the standard Polynomial type before continuing.","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"reference/#Inspection-1","page":"Reference/API","title":"Inspection","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"coeffs\ndegree\nlength\nsize\ndomain\nmapdomain\nchop\nchop!\ntruncate\ntruncate!\nisreal\nreal\nisintegral\nismonic","category":"page"},{"location":"reference/#Polynomials.coeffs","page":"Reference/API","title":"Polynomials.coeffs","text":"coeffs(::AbstractPolynomial)\n\nReturn the coefficient vector [a_0, a_1, ..., a_n] of a polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.degree","page":"Reference/API","title":"Polynomials.degree","text":"degree(::AbstractPolynomial)\n\nReturn the degree of the polynomial, i.e. the highest exponent in the polynomial that has a nonzero coefficient. The degree of the zero polynomial is defined to be -1. The default method assumes the basis polynomial, βₖ has degree k.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.length","page":"Reference/API","title":"Base.length","text":"length(::AbstractPolynomial)\n\nThe length of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.size","page":"Reference/API","title":"Base.size","text":"size(::AbstractPolynomial, [i])\n\nReturns the size of the polynomials coefficients, along axis i if provided.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.domain","page":"Reference/API","title":"Polynomials.domain","text":"domain(::Type{<:AbstractPolynomial})\n\nReturns the domain of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.mapdomain","page":"Reference/API","title":"Polynomials.mapdomain","text":"mapdomain(::Type{<:AbstractPolynomial}, x::AbstractArray)\nmapdomain(::AbstractPolynomial, x::AbstractArray)\n\nGiven values of x that are assumed to be unbounded (-∞, ∞), return values rescaled to the domain of the given polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> x = -10:10\n-10:10\n\njulia> extrema(mapdomain(ChebyshevT, x))\n(-1.0, 1.0)\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.chop","page":"Reference/API","title":"Base.chop","text":"chop(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nRemoves any leading coefficients that are approximately 0 (using rtol and atol). Returns a polynomial whose degree will guaranteed to be equal to or less than the given polynomial's.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.chop!","page":"Reference/API","title":"Polynomials.chop!","text":"chop!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0))\n\nIn-place version of chop\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.truncate","page":"Reference/API","title":"Base.truncate","text":"truncate(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nRounds off coefficients close to zero, as determined by rtol and atol, and then chops any leading zeros. Returns a new polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.truncate!","page":"Reference/API","title":"Polynomials.truncate!","text":"truncate!(::AbstractPolynomial{T};\n    rtol::Real = Base.rtoldefault(real(T)), atol::Real = 0)\n\nIn-place version of truncate\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.isreal","page":"Reference/API","title":"Base.isreal","text":"isreal(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a real polynomial, i.e., having only real numbers as coefficients.\n\nSee also: real\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.real","page":"Reference/API","title":"Base.real","text":"real(p::AbstractPolynomial)\n\nConstruct a real polynomial from the real parts of the coefficients of p.\n\nSee also: isreal\n\nnote: Note\nThis could cause losing terms in p. This method is usually called on polynomials like p = Polynomial([1, 2 + 0im, 3.0, 4.0 + 0.0im]) where you want to chop the imaginary parts of the coefficients of p.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.isintegral","page":"Reference/API","title":"Polynomials.isintegral","text":"isintegral(p::AbstractPolynomial)\n\nDetermine whether a polynomial is an integer polynomial, i.e., having only integers as coefficients.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.ismonic","page":"Reference/API","title":"Polynomials.ismonic","text":"ismonic(p::AbstractPolynomial)\n\nDetermine whether a polynomial is a monic polynomial, i.e., its leading coefficient is one.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Arithmetic-1","page":"Reference/API","title":"Arithmetic","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"All AbstractPolynomials have basic arithmetic operations defined on them (+, -, *, /, ÷, %, ==).","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"julia> p = Polynomial([1, 2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"gcd","category":"page"},{"location":"reference/#Base.gcd","page":"Reference/API","title":"Base.gcd","text":"gcd(a::AbstractPolynomial, b::AbstractPolynomial; atol::Real=0, rtol::Real=Base.rtoldefault)\n\nFind the greatest common denominator of two polynomials recursively using Euclid's algorithm.\n\nExamples\n\njulia> using Polynomials\n\njulia> gcd(fromroots([1, 1, 2]), fromroots([1, 2, 3]))\nPolynomial(4.0 - 6.0*x + 2.0*x^2)\n\n\n\n\n\n\ngcd(p1::StandardBasisPolynomial, p2::StandardBasisPolynomial; method=:eculidean, kwargs...)\n\nFind the greatest common divisor.\n\nBy default, uses the Euclidean division algorithm (method=:euclidean), which is susceptible to floating point issues.\n\nPassing method=:noda_sasaki uses scaling to circumvent some of these.\n\nPassing method=:numerical will call the internal method NGCD.ngcd for the numerical gcd. See the help page of Polynomials.NGCD.ngcd for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-Functions-1","page":"Reference/API","title":"Mathematical Functions","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"zero\none\nvariable\nfromroots\nroots\nderivative\nintegrate\nfit\ncompanion\nvander","category":"page"},{"location":"reference/#Base.zero","page":"Reference/API","title":"Base.zero","text":"zero(::Type{<:AbstractPolynomial})\nzero(::AbstractPolynomial)\n\nReturns a representation of 0 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.one","page":"Reference/API","title":"Base.one","text":"one(::Type{<:AbstractPolynomial})\none(::AbstractPolynomial)\n\nReturns a representation of 1 as the given polynomial.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.variable","page":"Reference/API","title":"Polynomials.variable","text":"variable(var=:x)\nvariable(::Type{<:AbstractPolynomial}, var=:x)\nvariable(p::AbstractPolynomial, var=indeterminate(p))\n\nReturn the monomial x in the indicated polynomial basis.  If no type is give, will default to Polynomial. Equivalent  to  P(var).\n\nExamples\n\njulia> using Polynomials\n\njulia> x = variable()\nPolynomial(x)\n\njulia> p = 100 + 24x - 3x^2\nPolynomial(100 + 24*x - 3*x^2)\n\njulia> roots((x - 3) * (x + 2))\n2-element Vector{Float64}:\n -2.0\n  3.0\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fromroots","page":"Reference/API","title":"Polynomials.fromroots","text":"fromroots(::AbstractVector{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractVector{<:Number}; var=:x)\n\nConstruct a polynomial of the given type given the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> r = [3, 2]; # (x - 3)(x - 2)\n\njulia> fromroots(r)\nPolynomial(6 - 5*x + x^2)\n\n\n\n\n\nfromroots(::AbstractMatrix{<:Number}; var=:x)\nfromroots(::Type{<:AbstractPolynomial}, ::AbstractMatrix{<:Number}; var=:x)\n\nConstruct a polynomial of the given type using the eigenvalues of the given matrix as the roots. If no type is given, defaults to Polynomial.\n\nExamples\n\njulia> using Polynomials\n\njulia> A = [1 2; 3 4]; # (x - 5.37228)(x + 0.37228)\n\njulia> fromroots(A)\nPolynomial(-1.9999999999999998 - 5.0*x + 1.0*x^2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.roots","page":"Reference/API","title":"Polynomials.roots","text":"roots(::AbstractPolynomial; kwargs...)\n\nReturns the roots of the given polynomial. This is calculated via the eigenvalues of the companion matrix. The kwargs are passed to the LinearAlgeebra.eigvals call.\n\nnote: Note\nThe [PolynomialRoots.jl](https://github.com/giordano/PolynomialRoots.jl) package provides an alternative that is a bit faster and a bit more accurate; the [FastPolynomialRoots](https://github.com/andreasnoack/FastPolynomialRoots.jl) provides an interface to FORTRAN code implementing an algorithm that can handle very large polynomials (it is  `O(n^2)` not `O(n^3)`. The [AMRVW.jl](https://github.com/jverzani/AMRVW.jl) package implements the algorithm in Julia, allowing the use of other  number types.\n\n\n\n\n\nroots(p)\n\nCompute the roots of the Laurent polynomial p.\n\nThe roots of a function (Laurent polynomial in this case) a(z) are the values of z for which the function vanishes. A Laurent polynomial a(z) = a_m z^m + a_m+1 z^m+1 +  + a_-1 z^-1 + a_0 + a_1 z +  + a_n-1 z^n-1 + a_n z^n can equivalently be viewed as a rational function with a multiple singularity (pole) at the origin. The roots are then the roots of the numerator polynomial. For example, a(z) = 1z + 2 + z can be written as a(z) = (1+2z+z^2)  z and the roots of a are the roots of 1+2z+z^2.\n\nExample\n\njulia> using Polynomials;\n\njulia> p = LaurentPolynomial([24,10,-15,0,1],-2:1,:z)\nLaurentPolynomial(24*z⁻² + 10*z⁻¹ - 15 + z²)\n\njulia> roots(a)\n4-element Array{Float64,1}:\n -3.999999999999999\n -0.9999999999999994\n  1.9999999999999998\n  2.9999999999999982\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.derivative","page":"Reference/API","title":"Polynomials.derivative","text":"derivative(::AbstractPolynomial, order::Int = 1)\n\nReturns a polynomial that is the orderth derivative of the given polynomial. order must be non-negative.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.integrate","page":"Reference/API","title":"Polynomials.integrate","text":"integrate(p::AbstractPolynomial)\n\nReturn an antiderivative for p\n\n\n\n\n\nintegrate(::AbstractPolynomial, C)\n\nReturns the indefinite integral of the polynomial with constant C when expressed in the standard basis.\n\n\n\n\n\nintegrate(::AbstractPolynomial, a, b)\n\nCompute the definite integral of the given polynomial from a to b. Will throw an error if either a or b are out of the polynomial's domain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.fit","page":"Reference/API","title":"Polynomials.fit","text":"fit(x, y, deg=length(x) - 1; [weights], var=:x)\nfit(::Type{<:AbstractPolynomial}, x, y, deg=length(x)-1; [weights], var=:x)\n\nFit the given data as a polynomial type with the given degree. Uses linear least squares to minimize the norm  ||y - V⋅β||^2, where V is the Vandermonde matrix and β are the coefficients of the polynomial fit.\n\nThis will automatically scale your data to the domain of the polynomial type using mapdomain. The default polynomial type is Polynomial.\n\nWeights\n\nWeights may be assigned to the points by specifying a vector or matrix of weights. \n\nWhen specified as a vector, [w₁,…,wₙ], the weights should be non-negative as the minimization problem is argmin_β Σᵢ wᵢ |yᵢ - Σⱼ Vᵢⱼ βⱼ|² = argmin_β || √(W)⋅(y - V(x)β)||², where, W the digonal matrix formed from [w₁,…,wₙ], is used for the solution, V being the Vandermonde matrix of x corresponding to the specified degree. This parameterization of the weights is different from that of numpy.polyfit, where the weights would be specified through  [ω₁,ω₂,…,ωₙ] = [√w₁, √w₂,…,√wₙ]  with the answer solving  argminᵦ | (ωᵢ⋅yᵢ- ΣⱼVᵢⱼ(ω⋅x) βⱼ) |^2.\n\nWhen specified as a matrix, W, the solution is through the normal equations (VᵀWV)β = (Vᵀy), again V being the Vandermonde matrix of x corresponding to the specified degree.\n\n(In statistics, the vector case corresponds to weighted least squares, where weights are typically given by wᵢ = 1/σᵢ², the σᵢ² being the variance of the measurement; the matrix specification follows that of the generalized least squares estimator with W = Σ⁻¹, the inverse of the variance-covariance matrix.)\n\nlarge degree\n\nFor fitting with a large degree, the Vandermonde matrix is exponentially ill-conditioned. The ArnoldiFit type introduces an Arnoldi orthogonalization that fixes this problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.companion","page":"Reference/API","title":"Polynomials.companion","text":"companion(::AbstractPolynomial)\n\nReturn the companion matrix for the given polynomial.\n\nReferences\n\nCompanion Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomials.vander","page":"Reference/API","title":"Polynomials.vander","text":"vander(::Type{AbstractPolynomial}, x::AbstractVector, deg::Integer)\n\nCalculate the psuedo-Vandermonde matrix of the given polynomial type with the given degree.\n\nReferences\n\nVandermonde Matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#Plotting-1","page":"Reference/API","title":"Plotting","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"Polynomials can be plotted directly using Plots.jl.","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial; kwds...)","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"will automatically determine a range based on the critical points (roots, extrema and points of inflection).","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"plot(::AbstractPolynomial, a, b; kwds...)","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"will plot the polynomial within the range [a, b].","category":"page"},{"location":"reference/#Example:-The-Polynomials.jl-logo-1","page":"Reference/API","title":"Example: The Polynomials.jl logo","text":"","category":"section"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"using Plots, Polynomials\n# T1, T2, T3, and T4:\nchebs = [\n  ChebyshevT([0, 1]),\n  ChebyshevT([0, 0, 1]),\n  ChebyshevT([0, 0, 0, 1]),\n  ChebyshevT([0, 0, 0, 0, 1]),\n]\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\nitr = zip(chebs, colors)\n(cheb,col), state = iterate(itr)\np = plot(cheb, c=col,  lw=5, legend=false, label=\"\")\nfor (cheb, col) in Base.Iterators.rest(itr, state)\n  plot!(cheb, c=col, lw=5)\nend\nsavefig(\"chebs.svg\"); nothing # hide","category":"page"},{"location":"reference/#","page":"Reference/API","title":"Reference/API","text":"(Image: )","category":"page"},{"location":"#Polynomials.jl-1","page":"Home","title":"Polynomials.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Polynomials.jl is a Julia package that provides basic arithmetic, integration, differentiation, evaluation, and root finding over dense univariate polynomials.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install the package, run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.2) pkg> add Polynomials","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package can then be loaded into the current session using","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Polynomials","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Construction-and-Evaluation-1","page":"Home","title":"Construction and Evaluation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Construct a polynomial from its coefficients, lowest order first.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> Polynomial([1,0,3,4])\nPolynomial(1 + 3*x^2 + 4*x^3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An optional variable parameter can be added.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> Polynomial([1,2,3], :s)\nPolynomial(1 + 2*s + 3*s^2)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Construct a polynomial from its roots.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fromroots([1,2,3]) # (x-1)*(x-2)*(x-3)\nPolynomial(-6 + 11*x - 6*x^2 + x^3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Evaluate the polynomial p at x.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> p(1)\n0\n","category":"page"},{"location":"#Arithmetic-1","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2])\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1, 0, -1])\nPolynomial(1 - x^2)\n\njulia> 2p\nPolynomial(2 + 4*x)\n\njulia> 2 + p\nPolynomial(3 + 2*x)\n\njulia> p - q\nPolynomial(2*x + x^2)\n\njulia> p * q\nPolynomial(1 + 2*x - x^2 - 2*x^3)\n\njulia> q / 2\nPolynomial(0.5 - 0.5*x^2)\n\njulia> q ÷ p  # `div`, also `rem` and `divrem`\nPolynomial(0.25 - 0.5*x)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that operations involving polynomials with different variables will error.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial([1, 2, 3], :s)\nPolynomial(1 + 2*s + 3*s^2)\n\njulia> p + q\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Except for operations  involving constant polynomials.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1, 2, 3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> q = Polynomial(1, :y)\nPolynomial(1)\n\njulia> p+q\nPolynomial(2 + 2*x + 3*x^2)","category":"page"},{"location":"#Integrals-and-Derivatives-1","page":"Home","title":"Integrals and Derivatives","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Integrate the polynomial p term by term, optionally adding constant term C. The degree of the resulting polynomial is one higher than the degree of p.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> integrate(Polynomial([1, 0, -1]))\nPolynomial(1.0*x - 0.3333333333333333*x^3)\n\njulia> integrate(Polynomial([1, 0, -1]), 2)\nPolynomial(2.0 + 1.0*x - 0.3333333333333333*x^3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Differentiate the polynomial p term by term. The degree of the resulting polynomial is one lower than the degree of p.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> derivative(Polynomial([1, 3, -1]))\nPolynomial(3 - 2*x)","category":"page"},{"location":"#Root-finding-1","page":"Home","title":"Root-finding","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Return the roots (zeros) of p, with multiplicity. The number of roots returned is equal to the order of p. By design, this is not type-stable, the returned roots may be real or complex.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> roots(Polynomial([1, 0, -1]))\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> roots(Polynomial([1, 0, 1]))\n2-element Vector{ComplexF64}:\n 0.0 - 1.0im\n 0.0 + 1.0im\n\njulia> roots(Polynomial([0, 0, 1]))\n2-element Vector{Float64}:\n 0.0\n 0.0","category":"page"},{"location":"#Fitting-arbitrary-data-1","page":"Home","title":"Fitting arbitrary data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Fit a polynomial (of degree deg) to x and y using polynomial interpolation or a (weighted) least-squares approximation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Plots, Polynomials\nxs = range(0, 10, length=10)\nys = @. exp(-xs)\nf = fit(xs, ys) # degree = length(xs) - 1 \nf2 = fit(xs, ys, 2) # degree = 2\n\nscatter(xs, ys, markerstrokewidth=0, label=\"Data\")\nplot!(f, extrema(xs)..., label=\"Fit\")\nplot!(f2, extrema(xs)..., label=\"Quadratic Fit\")\nsavefig(\"polyfit.svg\"); nothing # hide","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Other-bases-1","page":"Home","title":"Other bases","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A polynomial, e.g. a_0 + a_1 x + a_2 x^2 + ... + a_n x^n, can be seen as a collection of coefficients, [a_0, a_1, ..., a_n], relative to some polynomial basis. The most  familiar basis being  the standard one: 1, x, x^2, ...  Alternative bases are possible.  The ChebyshevT polynomials are  implemented, as an example. Instead of Polynomial  or  Polynomial{T}, ChebyshevT or  ChebyshevT{T} constructors are used:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p1 = ChebyshevT([1.0, 2.0, 3.0])\nChebyshevT(1.0⋅T_0(x) + 2.0⋅T_1(x) + 3.0⋅T_2(x))\n\njulia> p2 = ChebyshevT{Float64}([0, 1, 2])\nChebyshevT(1.0⋅T_1(x) + 2.0⋅T_2(x))\n\njulia> p1 + p2\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_1(x) + 5.0⋅T_2(x))\n\njulia> p1 * p2\nChebyshevT(4.0⋅T_0(x) + 4.5⋅T_1(x) + 3.0⋅T_2(x) + 3.5⋅T_3(x) + 3.0⋅T_4(x))\n\njulia> derivative(p1)\nChebyshevT(2.0⋅T_0(x) + 12.0⋅T_1(x))\n\njulia> integrate(p2)\nChebyshevT(- 1.0⋅T_1(x) + 0.25⋅T_2(x) + 0.3333333333333333⋅T_3(x))\n\njulia> convert(Polynomial, p1)\nPolynomial(-2.0 + 2.0*x + 6.0*x^2)\n\njulia> convert(ChebyshevT, Polynomial([1.0, 2,  3]))\nChebyshevT(2.5⋅T_0(x) + 2.0⋅T_1(x) + 1.5⋅T_2(x))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Warning\nThe older  Poly type that this package used prior to v0.7  is implemented as an alternate basis  to provide support for older code bases. As of v1.0,  this type will be only available by executing using Polynomials.PolyCompat.","category":"page"},{"location":"#Iteration-1","page":"Home","title":"Iteration","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If its basis is implicit, then a polynomial may be  seen as just a vector of  coefficients. Vectors or 1-based, but, for convenience, polynomial types are 0-based, for purposes of indexing (e.g. getindex, setindex!, eachindex). Iteration over a polynomial steps through the underlying coefficients.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> as = [1,2,3,4,5]; p = Polynomial(as);\n\njulia> as[3], p[2], collect(p)[3]\n(3, 3, 3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The pairs iterator, iterates over the indices and coefficients, attempting to match how pairs applies to the underlying storage model:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> v = [1,2,0,4]\n4-element Vector{Int64}:\n 1\n 2\n 0\n 4\n\njulia> p,ip,sp,lp = Polynomial(v), ImmutablePolynomial(v), SparsePolynomial(v), LaurentPolynomial(v, -1);\n\njulia> collect(pairs(p))\n4-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 1 => 2\n 2 => 0\n 3 => 4\n\njulia> collect(pairs(ip)) == collect(pairs(p))\ntrue\n\njulia> collect(pairs(sp)) # unordered dictionary with only non-zero terms\n3-element Vector{Pair{Int64, Int64}}:\n 0 => 1\n 3 => 4\n 1 => 2\n\njulia> collect(pairs(lp))\n4-element Vector{Pair{Int64, Int64}}:\n -1 => 1\n  0 => 2\n  1 => 0\n  2 => 4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The unexported monomials iterator iterates over the terms (p[i]*Polynomials.basis(p,i)) of the polynomial:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2,0,4], :u)\nPolynomial(1 + 2*u + 4*u^3)\n\njulia> collect(Polynomials.monomials(p))\n4-element Vector{Any}:\n Polynomial(1)\n Polynomial(2*u)\n Polynomial(0)\n Polynomial(4*u^3)","category":"page"},{"location":"#Relationship-between-the-T-and-P{T,X}-1","page":"Home","title":"Relationship between the T and P{T,X}","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The addition of a polynomial and a scalar, such as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Polynomials\n\njulia> p = Polynomial([1,2,3], :x)\nPolynomial(1 + 2*x + 3*x^2)\n\njulia> p + 3\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"seems natural, but in Julia, as 3 is of type Int and p of type Polynomial{Int,:x} some addition must be defined. The basic idea  is that 3 is promoted to the constant polynomial 3 with indeterminate :x as 3*one(p) and then addition of p + 3*one(p) is performed.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This identification of a scalar with a constant polynomial can go both ways. If q is a constant polynomial of type Polynomial{Int, :y} then we should expect that p+q would be defined, as p plus the constant term of q. Indeed this is the case","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> q = Polynomial(3, :y)\nPolynomial(3)\n\njulia> p + q\nPolynomial(4 + 2*x + 3*x^2)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If q is non-constant, such as variable(Polynomial, :y), then there would be an error due to the mismatched symbols. (The mathematical result would need a multivariate polynomial, not a univariate polynomial, as this package provides.)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The same conversion is done for polynomial multiplication: constant polynomials are treated as numbers; non-constant polynomials must have their symbols match. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There is an oddity though the following two computations look the same, they are technically different:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> one(Polynomial, :x) + one(Polynomial, :y)\nPolynomial(2.0)\n\njulia> one(Polynomial, :y) + one(Polynomial, :x)\nPolynomial(2.0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Both are constant polynomials over Int, but the first has the indeterminate :y, the second :x. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This technical difference causes no issues with polynomial addition or multiplication, as there constant polynomials are treated as numbers, but can be an issue when constant polynomials are used as array elements.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For arrays, the promotion of numbers to polynomials, allows natural constructions like:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> p = Polynomial([1,2],:x)\nPolynomial(1 + 2*x)\n\njulia> q = Polynomial([1,2],:y)  # non-constant polynomials with different indeterminates\nPolynomial(1 + 2*y)\n\njulia> [1 p]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1 + 2*x)\n\njulia> [1 one(q)]\n1×2 Matrix{Polynomial{Int64, :y}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, as there would be an ambiguous outcome of the following","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> [one(p) one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"an error thrown.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In general, arrays with mixtures of non-constant polynomials with different indeterminates will error. By default, an error will occur when constant polynomials with different indeterminates are used as components. However, for typed arrays, conversion will allow such constructs to be used.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Using one(q) for a constant polynomial with indeterminate :y we have:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> P = typeof(p)\nPolynomial{Int64, :x}\n\njulia> P[one(p) one(q)]\n1×2 Matrix{Polynomial{Int64, :x}}:\n Polynomial(1)  Polynomial(1)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Of course, by not being explicit, there are sill gotchas. For example, we can construct this matrix without a specific types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> [one(p), one(q)+one(p)]\n2-element Vector{Polynomial{Int64, :x}}:\n Polynomial(1)\n Polynomial(2)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"but not this one:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> [one(p), one(p) + one(q)]\nERROR: ArgumentError: Polynomials have different indeterminates\n[...]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Also, mixing types can result in unspecific symbols, as this example shows:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> [1 p; p 1] + [1 2one(q); 3 4] # array{P{T,:x}} + array{P{T,:y}}\n2×2 Matrix{Polynomial{Int64, X} where X}:\n Polynomial(2)        Polynomial(3 + 2*x)\n Polynomial(4 + 2*x)  Polynomial(5)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Though were a non-constant polynomial with indeterminate y replacing 2one(q) above, that addition would throw an error.","category":"page"},{"location":"#Related-Packages-1","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"StaticUnivariatePolynomials.jl Fixed-size univariate polynomials backed by a Tuple\nMultiPoly.jl for sparse multivariate polynomials\nDynamicPolynomals.jl Multivariate polynomials implementation of commutative and non-commutative variables\nMultivariatePolynomials.jl for multivariate polynomials and moments of commutative or non-commutative variables\nPolynomialRings.jl A library for arithmetic and algebra with multi-variable polynomials.\nAbstractAlgebra.jl, Nemo.jl for generic polynomial rings, matrix spaces, fraction fields, residue rings, power series, Hecke.jl for algebraic number theory.\nCommutativeAlgebra.jl the start of a computer algebra system specialized to discrete calculations with support for polynomials.\nPolynomialRoots.jl for a fast complex polynomial root finder. For larger degree problems, also FastPolynomialRoots and AMRVW.\nSpecialPolynomials.jl A package providing various polynomial types beyond the standard basis polynomials in Polynomials.jl. Includes interpolating polynomials, Bernstein polynomials, and classical orthogonal polynomials.\nClassicalOrthogonalPolynomials.jl A Julia package for classical orthogonal polynomials and expansions. Includes chebyshevt, chebyshevu, legendrep, jacobip, ultrasphericalc, hermiteh, and laguerrel. The same repository includes FastGaussQuadrature.jl, FastTransforms.jl, and the ApproxFun packages.","category":"page"},{"location":"#Contributing-1","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in this project, feel free to open an issue or pull request! In general, any changes must be thoroughly tested, allow deprecation, and not deviate too far from the common interface. All PR's must have an updated project version, as well, to keep the continuous delivery cycle up-to-date.","category":"page"},{"location":"polynomials/chebyshev/#Chebyshev-Polynomials-1","page":"Chebyshev","title":"Chebyshev Polynomials","text":"","category":"section"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"DocTestSetup = quote\n  using Polynomials\nend","category":"page"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"The Chebyshev polynomials are two sequences of polynomials, T_n and U_n. The Chebyshev polynomials of the first kind, T_n, can be defined by the recurrence relation T_0(x)=1, T_1(x)=x, and T_{n+1}(x) = 2xT_n{x}-T_{n-1}(x). The Chebyshev polynomioals of the second kind, U_n(x), can be defined by U_0(x)=1, U_1(x)=2x, and U_{n+1}(x) = 2xU_n(x) - U_{n-1}(x). Both T_n and U_n have degree n, and any polynomial  of  degree n may be uniquely written as a linear combination of the polynomials T_0, T_1, ..., T_n (similarly with U).","category":"page"},{"location":"polynomials/chebyshev/#First-Kind-1","page":"Chebyshev","title":"First Kind","text":"","category":"section"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"ChebyshevT","category":"page"},{"location":"polynomials/chebyshev/#Polynomials.ChebyshevT","page":"Chebyshev","title":"Polynomials.ChebyshevT","text":"ChebyshevT{T<:Number, X}(coeffs::AbstractVector)\n\nChebyshev polynomial of the first kind.\n\nConstruct a polynomial from its coefficients coeffs, lowest order first, optionally in terms of the given variable var, which can be a character, symbol, or string.\n\nnote: Note\nChebyshevT is not axis-aware, and it treats coeffs simply as a list of coefficients with the first  index always corresponding to the coefficient of T_0(x).\n\nExamples\n\njulia> using Polynomials\n\njulia> p = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\njulia> ChebyshevT([1, 2, 3, 0], :s)\nChebyshevT(1⋅T_0(s) + 2⋅T_1(s) + 3⋅T_2(s))\n\njulia> one(ChebyshevT)\nChebyshevT(1.0⋅T_0(x))\n\njulia> p(0.5)\n-4.5\n\njulia> Polynomials.evalpoly(5.0, p, false) # bypasses the domain check done in p(5.0)\n2088.0\n\nThe latter shows how to evaluate a ChebyshevT polynomial outside of its domain, which is [-1,1]. (For newer versions of Julia, evalpoly is an exported function from Base with methods extended in this package, so the module qualification is unnecessary.\n\n!!! Note:     The Chebyshev polynomials are also implemented in ApproxFun, ClassicalOrthogonalPolynomials.jl, FastTransforms.jl, and SpecialPolynomials.jl.\n\n\n\n\n\n","category":"type"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"The ChebyshevT type holds coefficients representing the polynomial a_0 T_0 + a_1 T_1 + ... + a_n T_n.","category":"page"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"For example, the basis polynomial T_4 can be represented with ChebyshevT([0,0,0,0,1]).","category":"page"},{"location":"polynomials/chebyshev/#Conversion-1","page":"Chebyshev","title":"Conversion","text":"","category":"section"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"ChebyshevT can be converted to Polynomial and vice-versa.","category":"page"},{"location":"polynomials/chebyshev/#","page":"Chebyshev","title":"Chebyshev","text":"julia> c = ChebyshevT([1, 0, 3, 4])\nChebyshevT(1⋅T_0(x) + 3⋅T_2(x) + 4⋅T_3(x))\n\n\njulia> p = convert(Polynomial, c)\nPolynomial(-2.0 - 12.0*x + 6.0*x^2 + 16.0*x^3)\n\njulia> convert(ChebyshevT, p)\nChebyshevT(1.0⋅T_0(x) + 3.0⋅T_2(x) + 4.0⋅T_3(x))","category":"page"}]
}
